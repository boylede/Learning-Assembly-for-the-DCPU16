{"name":"Learning Assembly for the DCPU16","tagline":"Example code and documentation for Notch's space game.","body":"# Learning DCPU Assembly\r\n\r\nI (@boylede) am by no means an expert on any programming topic, but I thought this would be fun to write. Comments & critisism welcomed. \r\n\r\n\r\n## Requisite Knowledge \r\nIt is not neccessary to understand binary completely to start out. All that you need to know is that binary is the only way computers think, and that they don't \"know\" that any data should be interpreted in a specific way other than how the programmer tells them to. Also, you must know that the smallest peice of data the DCPU deals with is 16 bits, which means that a peice of information can be any one of 65,536 values, and nothing else. This piece of data is called a ```word```.\r\n \r\n## Instructions\r\nAssembly is essentially a more easily human-readable representation of machine code (or machine code is a machine-readable representation of assembly). Each instruction in assembly tells the processor to do one specific operation. DCPU assembly differs from an actual assembly language in that the operations are all designed to be easy to use by humans, whereas actual modern processors have instruction sets that are designed to be written by compilers and are not very human-friendly.\r\n\r\nIn DCPU machine code, each instruction is stored in one to three ```words```, depending on complexity. The first part of the instruction is the opcode. The opcode tells the processor which operation it is going to do, and the rest of the instruction is concerned with what pieces of data the processer should be manipulating.\r\n\r\nThere are a number of options for telling the DPCU which data to use. There are 8 registers to store data in, and 65,536 ```words``` of memory. You can also use literal values (e.g. a number).\r\n\r\n```\r\nset a, 11\r\nsub a, 4\r\n```\r\nThese two instructions would each translate into a single ```word``` of machine code when compiled. The first one sets the value of the ```a``` register to 11. The operation is ```set``` and the two peices of data are the ```a``` register and the literal value 11.\r\n\r\nThe next operation is ```sub```, and as you might expect it instructs the processor to subtract 4 from ```a```. The result is stored in ```a```, because the DCPU always stores the result in the first value.\r\n\r\nIt is not important right now to know what exact numerical opcodes these instructions will compile to, but it is important to understand that each assembly instruction is just a human-readable way to represent what will be compiled to machine code.\r\n\r\n## Registers\r\nRegisters are little peices of memory on the processor which are used to store values for immediate use. The dcpu has 6+2 general purpose registers and 4 special purpose registers.\r\n\r\n\r\n###General Purpose Registers:\r\n\r\nBecause the DCPU is made to be fun and simplified for humans, every register is one word and can be manipulated directly, except ```IA``` which I'll talk about later. Actual CPU achitectures can have differently sized registers which are for specific things, and which are full of little rules and tricks.\r\n\r\n```\r\nA, B, C\r\nX, Y, Z\r\nI, J \t\t; these two are sort of unique, hence 6+2\r\n```\r\n\r\nEach of the general purpose registers can be used for any arbitrary usage that the programmer wants to, but remember that ```I``` and ```J``` are unique in that there are two instructions which affect them directly.\r\n \r\n ```\r\n; sti means \"set then increment\". \r\n; std means \"set then decrement\".\r\n\r\n; examples\r\nsti A, 2 \t; sets a to 2 and then increments I and J\r\nstd B, 1 \t; sets b to 1 and then decrements I and J\r\n```\r\n\r\n### PC: Program Counter AKA Instruction Pointer\r\nThe special registers have specific uses. The most important to understand at first is ```PC```. This is the program counter, or instruction pointer, and it points to the location in memory where the current instruction is. After each instruction, ```pc``` is automatically incremented by 1 and then the instruction at that location is executed.\r\n\r\n### SP: Stack Pointer\r\nLike ```pc```, the stack pointer ```sp``` is used to keep track of a location in memory that the processor uses for other operations. In this case it is part of the stack, which is essentially an area of memory that values can be quickly stored in and retrieved from, but only in sequential order. We'll talk about the stack more later.\r\n\r\n### IA: Interrupt Address\r\nThis is another pointer which we'll talk about later. Essentially a programmer can define a subroutine which gets run when hardware wants to talk to the DCPU or when another subroutine calls an Interrupt.\r\n\r\n### EX: Excess Register\r\nThe exess register is used when a function overflows the 16 bit possible values. This is a very luxurious function of the DCPU because \"real\" architectures often only have 1 bit for overflow and it is shared between different uses. This provides 16 whole bits of extra information when an operation overflows.\r\n\r\n## Addressing\r\n````\r\nset a, 8 \t\t; set the A register to the literal value 8\r\nset a, [8]\t\t; set the A register to the value in memory at address 0x0008\r\nset a, [8+b]\t; set the A register to the value in memory at address (0x0008 plus B)\r\nset [a], 8\t\t; set the value at the memory address that is in the A register to 8 \r\n````\r\nAddressing means how you refer to a specific peice of data. On the DCPU, data can either be stored in a register or stored in memory. Using pointers to address a peice of memory is simple enough, just enclose the memory address in square brackets ```[address]``` and the DCPU will read from or write to that address. \r\n\r\nIn the third example above, the literal value 8 is added to the value stored in the ```a``` register to determine which memory address to read. (The value of the ```a``` register is not altered.) For example, this can be used in a loop to refer to one value after another in memory.\r\n\r\n```\r\nset a, 0\r\n:loop\r\nset [label+a], 0xe900\r\nadd a, 1\r\nifn a, 0xf\r\n\tset pc, loop\r\n\tsub pc, 1\r\n```\r\nThis will set 16 ```words``` of memory to 0xe900, because 0xf is 15 in hexidecimal (and we started at 0).\r\n\r\nThis might be useful if we want to copy a string out to the screen. Let's say we have configured the screen to read from memory at 0x8000, and we want to print the string stored at the label \"string\" onto the screen in yellow text on a blue background.\r\n\r\n```\r\nset i, 0x8000\r\nset j, string\r\n:loop\r\nbor [j], [color]\r\nsti [i], [j]\r\nifn [j], 0\r\n    set pc, loop\r\nsub pc, 1\r\n\r\n:color\r\ndat 0xe900 \r\n:string\r\ndat \"Hello World!\", 0\r\n```\r\nThe number 0xe900 represents yellow text on a blue background, we store it at a label so we can change it easily when we want, and the string too. Strings are often terminated with a 0 so that you know when the string is over without knowing how long it is in advance.\r\n\r\n\r\n## Pointers and Labels\r\nIn DCPU assembly, the ```[``` and ```]``` characters are used to enclose pointers. They mean that the value should be interpreted as a memory address, and that the value at that memory address is the one you are refering to. Consider this  pretend map of some memory:\r\n\r\n```\r\n0000: \t0FF0 000F 0000 F000\r\n0004: \t0012 0230 0205 07e0\r\n0008:\t0000 0001 0020 0000\r\n000C: \t0300 4000 0050 0b00\r\n``` \r\nI have represented memory in hexidecimal, which is often used in computing partly because it is more succinct than binary. Each four digit group represents one ```word``` of memory.\r\n\r\nThe values at the left are the offset, or the address, of each ```word``` of memory. The first ```word``` is numbered 0, and up from there to the total of 65,536 possible on the DCPU. The offset isn't actually part of the memory, it is just used for visualization.\r\n\r\nIn this memory map, the pointer [0003] would point to the value 0xF000, which you can see  on the first line. You can see the the first value on the next line is at offset 0004, which makes sense because it is one after 0003. \r\n\r\n\r\nConsider the following snippet:\r\n\r\n```\r\nset [data], 5\r\nsub pc, 1\r\ndata:\r\ndat 0\r\n```\r\n\r\nHere, ```data``` is a label, it is defined with a colon ```:``` following a string. When the program is complied, labels are translated into the memory address of the instruction after a label is defined. In this example ```dat 0``` is the next instruction (dat tells the compiler to include some literal values in the program, in this case ```0000```). So the line ```set [data], 5``` means to set the value of memory at ```data``` to 5. We've used ```data``` as a pointer to \"talk\" to a specific peice of memory. \r\n\r\nOften in simple programs it is usefull to assign a specific piece of memory to store a given value which you can then refer to in code by its label. This is what we have done above, with the label ```data```. I sometimes call these labels \"global variables\" because they are at a predefined location in memory and can be refered to in any subroutine by name.\r\n\r\n\r\n## Comments\r\nIn code, it is often usefull to annotate things with comments so that others, and even future you, can understand what the goal of a given subroutine is. This is done in DCPU-Assembly using semi-colons. Everything on that line after the semi-colon is ignored by the compiler.\r\n\r\n```\r\n; some random instructions:\r\nset a, 4\r\nsub i, 4\r\nmul b, 2\r\n; this is another comment\r\nhwi 8\r\nint 1 ; the comment doesnt have to be the first thing on the line.\r\nrfi a\r\n```\r\n\r\n## An example program\r\n\r\n````\r\n\tset a, 10\r\n\tset b, 0\r\nloop:\r\n\tadd b, a\r\n\tsub a, 1\r\n\tifn a, 0\r\n\t\tset pc, loop\r\n\tsub pc, 1\r\n\r\n````\r\nIn order to understand assembly you need to read through the program line by line. Hopefully, some of the instructions listed make sense even without learning the operations in advace, but lets talk about each line:\r\n\r\n````\r\n\tset a, 10\r\n\tset b, 0\r\n````\r\nThis is pretty self-explanatory: the ```a``` and ```b``` registers are set to some integer values, ```10``` and ```0```. These are represented in decimal, but they could be expressed in binary or hexidecimal also.\r\n\r\n````\r\nloop:\r\n````\r\nThis line defines a label, named loop.\r\n\r\n````\r\n\tadd b, a\r\n\tsub a, 1\r\n````\r\nThese two lines manipulate the registers we set up before. The first one adds the value of ```a``` into ```b```, the result is stored in ```b```. The next line reduces ```a``` by 1. \r\n\r\n````\r\n\tifn a, 0\r\n\t\tset pc, loop\r\n````\r\n```ifn``` is part of a series of operations which control program flow, called conditional operators. These operators check the two values that are supplied, and will either skip the next operation or not.\r\n\r\n```ifn``` checks to see if the first value is NOT equal to the second value. Since we set ```a``` to 10 and then subtracted 1, it will be 9 the first time it gets here. Since ```9 != 0```, the if statement will be true and the instruction after it **will** be executed. If it was false, it would skip the next instruction. The next instruction is indented in order to make it easier to read, but that is just for humans. The computer doesn't care how you indent things. \r\n\r\n```set pc, loop``` sets the instruction pointer to the label we set before, meaning that the next instruction that is evaluated will be ```add b, a```. This loop will be repeated until ```a == 0``` and then ```set pc, loop``` will be skipped, and ```sub pc, 1``` will be run.\r\n\r\n```\r\n\tsub pc, 1\r\n```\r\nAs you probably expect by now, this will subtract 1 from the instruction pointer. Each time the instruction pointer executes an instruction, it is automatically incremented so that it points to the next instruction to execute. Subtracting 1 undoes that addition, and ```pc``` will stay where it is forever. This is one way to stop execution. Currently, there is no real way to shut down the DCPU, so halting ```pc``` is the popular way to finish doing things.\r\n\r\n\r\n## Hardware\r\nDoing some basic math on the computer is all well and good, but lets explore talking with hardware.\r\n\r\nOn the DCPU, interfacing with hardware is done in a very consistant manner. First, you need to know what hardware is connected and what order it is connected in, so that your program can talk to each piece of hardware individually.\r\n\r\nIn order to do this, you first get the number of hardware devices connected,```hwn i```, and then iterate through them, talking to each one in turn to learn about it. ```hwq i``` will ask the hardware to return details about itself in the registers. ```hwi i``` will send a signal to the hardware called an Interrupt.\r\n\r\n### Hardware Interrupts\r\nEach piece of hardware is capable of talking directly with the DCPU's memory and getting the values of registers. The hardware is only allowed/supposed to do this when you ask it to by sending it an interrupt. \r\n\r\nOnce you know which device you want to comminucate with you can use ```hwi``` to send it an interrupt.\r\n\r\n```\r\n; \tsend an interrupt to the 21st piece of hardware connected\r\nhwi 21\r\n; \tsend an interrupt to the i'th piece of hardware.\r\nhwi i\r\n```\r\nUsually, the value of the ```a``` register, and possibly other registers, is set in order to communicate a certain intention to the piece of hardware.\r\n\r\nHardware specifications are posted to ```http:///www.dcpu.com```, and it is a good idea to peruse them in order to understand what kind of things you can do with hardware. All of the functionality is general enough to allow the programmer a fair amount of control over what is happening. This also means that not a whole lot is done for you, but that is OK as far as I am concerned.\r\n\r\n## First Assignment\r\nDesign a command line shell that can read input commands, compare them to a list of built-in commands, and then redirect program flow to the desired command. \r\n\r\nThis may seem rather daunting given the slim amount of information given above, but if you consider a multi-staged approach it is far from impossible.\r\n\r\n### Initialize\r\nProgram an algorithm which analyzes the pieces of hardware that are connected and stores the number needed to communicate with each in a pre-set label. \r\n### Hello World\r\nAdd to the above the ability to write to the screen. \r\n### Text Edit\r\nAdd the ability for the user to type arbitrary strings to the screen, and erase without allowing the user to currupt memory! It is up to you whether the user can write more than one screen full of text, but make sure your subroutines prevent the user from accidentally overwriting memory outside the screen space.\r\n### Command Interpet\r\nWrite an algorith that compares the input string to an internal list of strings until it finds a match, or fails. \r\n### Program Flow\r\nAdd the ability to redirect program flow to the desired command, and return to the shell when that \"command\" is finished.\r\n\r\n## First Assignment Examples\r\nExamples of each of the above milestones is included along with this document.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}